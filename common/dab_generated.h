// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DAB_FLATBNN_H_
#define FLATBUFFERS_GENERATED_DAB_FLATBNN_H_

#include "flatbuffers/flatbuffers.h"

namespace flatbnn {

struct Tensor;

struct Input;

struct Binarize;

struct BinConv2D;

struct FpConv2D;

struct AvePool;

struct MaxPool;

struct Relu;

struct Softmax;

struct FC;

struct Add;

struct Concat;

struct Shuffle;

struct Split;

struct Affine;

struct PRelu;

struct Layer;

struct Model;

enum class DataType : int8_t {
  Float32 = 0,
  Bit = 1,
  MIN = Float32,
  MAX = Bit
};

inline const DataType (&EnumValuesDataType())[2] {
  static const DataType values[] = {
    DataType::Float32,
    DataType::Bit
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[] = {
    "Float32",
    "Bit",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (e < DataType::Float32 || e > DataType::Bit) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class LayerType : int8_t {
  FpConv2D = 0,
  AvePool = 1,
  MaxPool = 2,
  Relu = 3,
  Softmax = 4,
  FC = 5,
  Add = 6,
  Concat = 7,
  BinConv2D = 8,
  Affine = 9,
  Binarize = 10,
  Split = 11,
  Shuffle = 12,
  PRelu = 13,
  MIN = FpConv2D,
  MAX = PRelu
};

inline const LayerType (&EnumValuesLayerType())[14] {
  static const LayerType values[] = {
    LayerType::FpConv2D,
    LayerType::AvePool,
    LayerType::MaxPool,
    LayerType::Relu,
    LayerType::Softmax,
    LayerType::FC,
    LayerType::Add,
    LayerType::Concat,
    LayerType::BinConv2D,
    LayerType::Affine,
    LayerType::Binarize,
    LayerType::Split,
    LayerType::Shuffle,
    LayerType::PRelu
  };
  return values;
}

inline const char * const *EnumNamesLayerType() {
  static const char * const names[] = {
    "FpConv2D",
    "AvePool",
    "MaxPool",
    "Relu",
    "Softmax",
    "FC",
    "Add",
    "Concat",
    "BinConv2D",
    "Affine",
    "Binarize",
    "Split",
    "Shuffle",
    "PRelu",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerType(LayerType e) {
  if (e < LayerType::FpConv2D || e > LayerType::PRelu) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerType()[index];
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_BIN_DATA = 6,
    VT_FLOAT32_DATA = 8,
    VT_SHAPE = 10,
    VT_NAME = 12,
    VT_ALIGN_HWC_TO_128 = 14
  };
  DataType data_type() const {
    return static_cast<DataType>(GetField<int8_t>(VT_DATA_TYPE, 0));
  }
  const flatbuffers::Vector<uint64_t> *bin_data() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_BIN_DATA);
  }
  const flatbuffers::Vector<float> *float32_data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOAT32_DATA);
  }
  const flatbuffers::Vector<uint32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SHAPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool align_hwc_to_128() const {
    return GetField<uint8_t>(VT_ALIGN_HWC_TO_128, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_BIN_DATA) &&
           verifier.VerifyVector(bin_data()) &&
           VerifyOffset(verifier, VT_FLOAT32_DATA) &&
           verifier.VerifyVector(float32_data()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_HWC_TO_128) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(DataType data_type) {
    fbb_.AddElement<int8_t>(Tensor::VT_DATA_TYPE, static_cast<int8_t>(data_type), 0);
  }
  void add_bin_data(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> bin_data) {
    fbb_.AddOffset(Tensor::VT_BIN_DATA, bin_data);
  }
  void add_float32_data(flatbuffers::Offset<flatbuffers::Vector<float>> float32_data) {
    fbb_.AddOffset(Tensor::VT_FLOAT32_DATA, float32_data);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_align_hwc_to_128(bool align_hwc_to_128) {
    fbb_.AddElement<uint8_t>(Tensor::VT_ALIGN_HWC_TO_128, static_cast<uint8_t>(align_hwc_to_128), 0);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType data_type = DataType::Float32,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> bin_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> float32_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> shape = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool align_hwc_to_128 = false) {
  TensorBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_shape(shape);
  builder_.add_float32_data(float32_data);
  builder_.add_bin_data(bin_data);
  builder_.add_align_hwc_to_128(align_hwc_to_128);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataType data_type = DataType::Float32,
    const std::vector<uint64_t> *bin_data = nullptr,
    const std::vector<float> *float32_data = nullptr,
    const std::vector<uint32_t> *shape = nullptr,
    const char *name = nullptr,
    bool align_hwc_to_128 = false) {
  auto bin_data__ = bin_data ? _fbb.CreateVector<uint64_t>(*bin_data) : 0;
  auto float32_data__ = float32_data ? _fbb.CreateVector<float>(*float32_data) : 0;
  auto shape__ = shape ? _fbb.CreateVector<uint32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return flatbnn::CreateTensor(
      _fbb,
      data_type,
      bin_data__,
      float32_data__,
      shape__,
      name__,
      align_hwc_to_128);
}

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_NAME = 6
  };
  const flatbuffers::Vector<uint32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SHAPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct InputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> shape) {
    fbb_.AddOffset(Input::VT_SHAPE, shape);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Input::VT_NAME, name);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputBuilder &operator=(const InputBuilder &);
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> shape = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *shape = nullptr,
    const char *name = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<uint32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return flatbnn::CreateInput(
      _fbb,
      shape__,
      name__);
}

struct Binarize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct BinarizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Binarize::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Binarize::VT_OUTPUT, output);
  }
  explicit BinarizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinarizeBuilder &operator=(const BinarizeBuilder &);
  flatbuffers::Offset<Binarize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Binarize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Binarize> CreateBinarize(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  BinarizeBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Binarize> CreateBinarizeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateBinarize(
      _fbb,
      input__,
      output__);
}

struct BinConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_PADS = 10,
    VT_STRIDES = 12,
    VT_DILATIONS = 14,
    VT_OUTPUT = 16
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *weight() const {
    return GetPointer<const flatbuffers::String *>(VT_WEIGHT);
  }
  const flatbuffers::String *bias() const {
    return GetPointer<const flatbuffers::String *>(VT_BIAS);
  }
  /// the order is top, right, bottom, left
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  /// the order is stride_h, stride_w
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  /// the order is dilation_h, dilation_w
  const flatbuffers::Vector<int32_t> *dilations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DILATIONS);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyString(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyString(bias()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_DILATIONS) &&
           verifier.VerifyVector(dilations()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct BinConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(BinConv2D::VT_INPUT, input);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::String> weight) {
    fbb_.AddOffset(BinConv2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::String> bias) {
    fbb_.AddOffset(BinConv2D::VT_BIAS, bias);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(BinConv2D::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(BinConv2D::VT_STRIDES, strides);
  }
  void add_dilations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations) {
    fbb_.AddOffset(BinConv2D::VT_DILATIONS, dilations);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(BinConv2D::VT_OUTPUT, output);
  }
  explicit BinConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinConv2DBuilder &operator=(const BinConv2DBuilder &);
  flatbuffers::Offset<BinConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinConv2D> CreateBinConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> weight = 0,
    flatbuffers::Offset<flatbuffers::String> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  BinConv2DBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_dilations(dilations);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<BinConv2D> CreateBinConv2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *weight = nullptr,
    const char *bias = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *dilations = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto weight__ = weight ? _fbb.CreateString(weight) : 0;
  auto bias__ = bias ? _fbb.CreateString(bias) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto dilations__ = dilations ? _fbb.CreateVector<int32_t>(*dilations) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateBinConv2D(
      _fbb,
      input__,
      weight__,
      bias__,
      pads__,
      strides__,
      dilations__,
      output__);
}

struct FpConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_PADS = 10,
    VT_STRIDES = 12,
    VT_DILATIONS = 14,
    VT_OUTPUT = 16
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *weight() const {
    return GetPointer<const flatbuffers::String *>(VT_WEIGHT);
  }
  const flatbuffers::String *bias() const {
    return GetPointer<const flatbuffers::String *>(VT_BIAS);
  }
  /// the order is top, right, bottom, left
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  /// the order is stride_h, stride_w
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  /// the order is dilation_h, dilation_w
  const flatbuffers::Vector<int32_t> *dilations() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DILATIONS);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyString(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyString(bias()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_DILATIONS) &&
           verifier.VerifyVector(dilations()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct FpConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(FpConv2D::VT_INPUT, input);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::String> weight) {
    fbb_.AddOffset(FpConv2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::String> bias) {
    fbb_.AddOffset(FpConv2D::VT_BIAS, bias);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(FpConv2D::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(FpConv2D::VT_STRIDES, strides);
  }
  void add_dilations(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations) {
    fbb_.AddOffset(FpConv2D::VT_DILATIONS, dilations);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(FpConv2D::VT_OUTPUT, output);
  }
  explicit FpConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FpConv2DBuilder &operator=(const FpConv2DBuilder &);
  flatbuffers::Offset<FpConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FpConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<FpConv2D> CreateFpConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> weight = 0,
    flatbuffers::Offset<flatbuffers::String> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dilations = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  FpConv2DBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_dilations(dilations);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<FpConv2D> CreateFpConv2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *weight = nullptr,
    const char *bias = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *dilations = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto weight__ = weight ? _fbb.CreateString(weight) : 0;
  auto bias__ = bias ? _fbb.CreateString(bias) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto dilations__ = dilations ? _fbb.CreateVector<int32_t>(*dilations) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateFpConv2D(
      _fbb,
      input__,
      weight__,
      bias__,
      pads__,
      strides__,
      dilations__,
      output__);
}

struct AvePool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_KERNEL_SHAPE = 6,
    VT_PADS = 8,
    VT_STRIDES = 10,
    VT_OUTPUT = 12
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  /// the order is kernel_h, kernel_w
  const flatbuffers::Vector<int32_t> *kernel_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNEL_SHAPE);
  }
  /// the order is top, right, bottom, left
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  /// the order is stride_h, stride_w
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_KERNEL_SHAPE) &&
           verifier.VerifyVector(kernel_shape()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct AvePoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(AvePool::VT_INPUT, input);
  }
  void add_kernel_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape) {
    fbb_.AddOffset(AvePool::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(AvePool::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(AvePool::VT_STRIDES, strides);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(AvePool::VT_OUTPUT, output);
  }
  explicit AvePoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AvePoolBuilder &operator=(const AvePoolBuilder &);
  flatbuffers::Offset<AvePool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AvePool>(end);
    return o;
  }
};

inline flatbuffers::Offset<AvePool> CreateAvePool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  AvePoolBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<AvePool> CreateAvePoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const std::vector<int32_t> *kernel_shape = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto kernel_shape__ = kernel_shape ? _fbb.CreateVector<int32_t>(*kernel_shape) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateAvePool(
      _fbb,
      input__,
      kernel_shape__,
      pads__,
      strides__,
      output__);
}

struct MaxPool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_KERNEL_SHAPE = 6,
    VT_PADS = 8,
    VT_STRIDES = 10,
    VT_OUTPUT = 12
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  /// the order is kernel_h, kernel_w
  const flatbuffers::Vector<int32_t> *kernel_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_KERNEL_SHAPE);
  }
  /// the order is top, right, bottom, left
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  /// the order is stride_h, stride_w
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_KERNEL_SHAPE) &&
           verifier.VerifyVector(kernel_shape()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct MaxPoolBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(MaxPool::VT_INPUT, input);
  }
  void add_kernel_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape) {
    fbb_.AddOffset(MaxPool::VT_KERNEL_SHAPE, kernel_shape);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(MaxPool::VT_PADS, pads);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(MaxPool::VT_STRIDES, strides);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(MaxPool::VT_OUTPUT, output);
  }
  explicit MaxPoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaxPoolBuilder &operator=(const MaxPoolBuilder &);
  flatbuffers::Offset<MaxPool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxPool>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxPool> CreateMaxPool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> kernel_shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  MaxPoolBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_strides(strides);
  builder_.add_pads(pads);
  builder_.add_kernel_shape(kernel_shape);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaxPool> CreateMaxPoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const std::vector<int32_t> *kernel_shape = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto kernel_shape__ = kernel_shape ? _fbb.CreateVector<int32_t>(*kernel_shape) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateMaxPool(
      _fbb,
      input__,
      kernel_shape__,
      pads__,
      strides__,
      output__);
}

struct Relu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct ReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Relu::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Relu::VT_OUTPUT, output);
  }
  explicit ReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReluBuilder &operator=(const ReluBuilder &);
  flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu> CreateRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  ReluBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Relu> CreateReluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateRelu(
      _fbb,
      input__,
      output__);
}

struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct SoftmaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Softmax::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Softmax::VT_OUTPUT, output);
  }
  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxBuilder &operator=(const SoftmaxBuilder &);
  flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<Softmax> CreateSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateSoftmax(
      _fbb,
      input__,
      output__);
}

struct FC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_OUTPUT = 10
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *weight() const {
    return GetPointer<const flatbuffers::String *>(VT_WEIGHT);
  }
  const flatbuffers::String *bias() const {
    return GetPointer<const flatbuffers::String *>(VT_BIAS);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyString(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyString(bias()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct FCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(FC::VT_INPUT, input);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::String> weight) {
    fbb_.AddOffset(FC::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::String> bias) {
    fbb_.AddOffset(FC::VT_BIAS, bias);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(FC::VT_OUTPUT, output);
  }
  explicit FCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FCBuilder &operator=(const FCBuilder &);
  flatbuffers::Offset<FC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FC>(end);
    return o;
  }
};

inline flatbuffers::Offset<FC> CreateFC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> weight = 0,
    flatbuffers::Offset<flatbuffers::String> bias = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  FCBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<FC> CreateFCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *weight = nullptr,
    const char *bias = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto weight__ = weight ? _fbb.CreateString(weight) : 0;
  auto bias__ = bias ? _fbb.CreateString(bias) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateFC(
      _fbb,
      input__,
      weight__,
      bias__,
      output__);
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT1 = 4,
    VT_INPUT2 = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::String *input1() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT1);
  }
  const flatbuffers::String *input2() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT2);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT1) &&
           verifier.VerifyString(input1()) &&
           VerifyOffset(verifier, VT_INPUT2) &&
           verifier.VerifyString(input2()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input1(flatbuffers::Offset<flatbuffers::String> input1) {
    fbb_.AddOffset(Add::VT_INPUT1, input1);
  }
  void add_input2(flatbuffers::Offset<flatbuffers::String> input2) {
    fbb_.AddOffset(Add::VT_INPUT2, input2);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Add::VT_OUTPUT, output);
  }
  explicit AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input1 = 0,
    flatbuffers::Offset<flatbuffers::String> input2 = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input2(input2);
  builder_.add_input1(input1);
  return builder_.Finish();
}

inline flatbuffers::Offset<Add> CreateAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input1 = nullptr,
    const char *input2 = nullptr,
    const char *output = nullptr) {
  auto input1__ = input1 ? _fbb.CreateString(input1) : 0;
  auto input2__ = input2 ? _fbb.CreateString(input2) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateAdd(
      _fbb,
      input1__,
      input2__,
      output__);
}

struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_AXIS = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUTS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct ConcatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Concat::VT_INPUTS, inputs);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Concat::VT_AXIS, axis, 0);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Concat::VT_OUTPUT, output);
  }
  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatBuilder &operator=(const ConcatBuilder &);
  flatbuffers::Offset<Concat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Concat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Concat> CreateConcat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> inputs = 0,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  ConcatBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_axis(axis);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<Concat> CreateConcatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *inputs = nullptr,
    int32_t axis = 0,
    const char *output = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*inputs) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateConcat(
      _fbb,
      inputs__,
      axis,
      output__);
}

struct Shuffle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUT = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct ShuffleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Shuffle::VT_INPUT, input);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Shuffle::VT_OUTPUT, output);
  }
  explicit ShuffleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShuffleBuilder &operator=(const ShuffleBuilder &);
  flatbuffers::Offset<Shuffle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shuffle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shuffle> CreateShuffle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  ShuffleBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shuffle> CreateShuffleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateShuffle(
      _fbb,
      input__,
      output__);
}

struct Split FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_OUTPUTS = 6
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           verifier.EndTable();
  }
};

struct SplitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Split::VT_INPUT, input);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Split::VT_OUTPUTS, outputs);
  }
  explicit SplitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitBuilder &operator=(const SplitBuilder &);
  flatbuffers::Offset<Split> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Split>(end);
    return o;
  }
};

inline flatbuffers::Offset<Split> CreateSplit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> outputs = 0) {
  SplitBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Split> CreateSplitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *outputs = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*outputs) : 0;
  return flatbnn::CreateSplit(
      _fbb,
      input__,
      outputs__);
}

struct Affine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_A = 6,
    VT_B = 8,
    VT_OUTPUT = 10
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *a() const {
    return GetPointer<const flatbuffers::String *>(VT_A);
  }
  const flatbuffers::String *b() const {
    return GetPointer<const flatbuffers::String *>(VT_B);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_A) &&
           verifier.VerifyString(a()) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.VerifyString(b()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct AffineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(Affine::VT_INPUT, input);
  }
  void add_a(flatbuffers::Offset<flatbuffers::String> a) {
    fbb_.AddOffset(Affine::VT_A, a);
  }
  void add_b(flatbuffers::Offset<flatbuffers::String> b) {
    fbb_.AddOffset(Affine::VT_B, b);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(Affine::VT_OUTPUT, output);
  }
  explicit AffineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AffineBuilder &operator=(const AffineBuilder &);
  flatbuffers::Offset<Affine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Affine>(end);
    return o;
  }
};

inline flatbuffers::Offset<Affine> CreateAffine(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> a = 0,
    flatbuffers::Offset<flatbuffers::String> b = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  AffineBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_b(b);
  builder_.add_a(a);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Affine> CreateAffineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *a = nullptr,
    const char *b = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto a__ = a ? _fbb.CreateString(a) : 0;
  auto b__ = b ? _fbb.CreateString(b) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreateAffine(
      _fbb,
      input__,
      a__,
      b__,
      output__);
}

struct PRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_SLOPE = 6,
    VT_OUTPUT = 8
  };
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  const flatbuffers::String *slope() const {
    return GetPointer<const flatbuffers::String *>(VT_SLOPE);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyString(slope()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct PReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(PRelu::VT_INPUT, input);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::String> slope) {
    fbb_.AddOffset(PRelu::VT_SLOPE, slope);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(PRelu::VT_OUTPUT, output);
  }
  explicit PReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PReluBuilder &operator=(const PReluBuilder &);
  flatbuffers::Offset<PRelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PRelu>(end);
    return o;
  }
};

inline flatbuffers::Offset<PRelu> CreatePRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input = 0,
    flatbuffers::Offset<flatbuffers::String> slope = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  PReluBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_slope(slope);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<PRelu> CreatePReluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input = nullptr,
    const char *slope = nullptr,
    const char *output = nullptr) {
  auto input__ = input ? _fbb.CreateString(input) : 0;
  auto slope__ = slope ? _fbb.CreateString(slope) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return flatbnn::CreatePRelu(
      _fbb,
      input__,
      slope__,
      output__);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_FP_CONV2D_PARAM = 6,
    VT_BIN_CONV2D_PARAM = 8,
    VT_AVEPOOL_PARAM = 10,
    VT_MAXPOOL_PARAM = 12,
    VT_RELU_PARAM = 14,
    VT_SOFTMAX_PARAM = 16,
    VT_FC_PARAM = 18,
    VT_ADD_PARAM = 20,
    VT_CONCAT_PARAM = 22,
    VT_AFFINE_PARAM = 24,
    VT_BINARIZE_PARAM = 26,
    VT_SPLIT_PARAM = 28,
    VT_SHUFFLE_PARAM = 30,
    VT_NAME = 32,
    VT_PRELU_PARAM = 34
  };
  LayerType type() const {
    return static_cast<LayerType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const FpConv2D *fp_conv2d_param() const {
    return GetPointer<const FpConv2D *>(VT_FP_CONV2D_PARAM);
  }
  const BinConv2D *bin_conv2d_param() const {
    return GetPointer<const BinConv2D *>(VT_BIN_CONV2D_PARAM);
  }
  const AvePool *avepool_param() const {
    return GetPointer<const AvePool *>(VT_AVEPOOL_PARAM);
  }
  const MaxPool *maxpool_param() const {
    return GetPointer<const MaxPool *>(VT_MAXPOOL_PARAM);
  }
  const Relu *relu_param() const {
    return GetPointer<const Relu *>(VT_RELU_PARAM);
  }
  const Softmax *softmax_param() const {
    return GetPointer<const Softmax *>(VT_SOFTMAX_PARAM);
  }
  const FC *fc_param() const {
    return GetPointer<const FC *>(VT_FC_PARAM);
  }
  const Add *add_param() const {
    return GetPointer<const Add *>(VT_ADD_PARAM);
  }
  const Concat *concat_param() const {
    return GetPointer<const Concat *>(VT_CONCAT_PARAM);
  }
  const Affine *affine_param() const {
    return GetPointer<const Affine *>(VT_AFFINE_PARAM);
  }
  const Binarize *binarize_param() const {
    return GetPointer<const Binarize *>(VT_BINARIZE_PARAM);
  }
  const Split *split_param() const {
    return GetPointer<const Split *>(VT_SPLIT_PARAM);
  }
  const Shuffle *shuffle_param() const {
    return GetPointer<const Shuffle *>(VT_SHUFFLE_PARAM);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const PRelu *prelu_param() const {
    return GetPointer<const PRelu *>(VT_PRELU_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FP_CONV2D_PARAM) &&
           verifier.VerifyTable(fp_conv2d_param()) &&
           VerifyOffset(verifier, VT_BIN_CONV2D_PARAM) &&
           verifier.VerifyTable(bin_conv2d_param()) &&
           VerifyOffset(verifier, VT_AVEPOOL_PARAM) &&
           verifier.VerifyTable(avepool_param()) &&
           VerifyOffset(verifier, VT_MAXPOOL_PARAM) &&
           verifier.VerifyTable(maxpool_param()) &&
           VerifyOffset(verifier, VT_RELU_PARAM) &&
           verifier.VerifyTable(relu_param()) &&
           VerifyOffset(verifier, VT_SOFTMAX_PARAM) &&
           verifier.VerifyTable(softmax_param()) &&
           VerifyOffset(verifier, VT_FC_PARAM) &&
           verifier.VerifyTable(fc_param()) &&
           VerifyOffset(verifier, VT_ADD_PARAM) &&
           verifier.VerifyTable(add_param()) &&
           VerifyOffset(verifier, VT_CONCAT_PARAM) &&
           verifier.VerifyTable(concat_param()) &&
           VerifyOffset(verifier, VT_AFFINE_PARAM) &&
           verifier.VerifyTable(affine_param()) &&
           VerifyOffset(verifier, VT_BINARIZE_PARAM) &&
           verifier.VerifyTable(binarize_param()) &&
           VerifyOffset(verifier, VT_SPLIT_PARAM) &&
           verifier.VerifyTable(split_param()) &&
           VerifyOffset(verifier, VT_SHUFFLE_PARAM) &&
           verifier.VerifyTable(shuffle_param()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PRELU_PARAM) &&
           verifier.VerifyTable(prelu_param()) &&
           verifier.EndTable();
  }
};

struct LayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(LayerType type) {
    fbb_.AddElement<int8_t>(Layer::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_fp_conv2d_param(flatbuffers::Offset<FpConv2D> fp_conv2d_param) {
    fbb_.AddOffset(Layer::VT_FP_CONV2D_PARAM, fp_conv2d_param);
  }
  void add_bin_conv2d_param(flatbuffers::Offset<BinConv2D> bin_conv2d_param) {
    fbb_.AddOffset(Layer::VT_BIN_CONV2D_PARAM, bin_conv2d_param);
  }
  void add_avepool_param(flatbuffers::Offset<AvePool> avepool_param) {
    fbb_.AddOffset(Layer::VT_AVEPOOL_PARAM, avepool_param);
  }
  void add_maxpool_param(flatbuffers::Offset<MaxPool> maxpool_param) {
    fbb_.AddOffset(Layer::VT_MAXPOOL_PARAM, maxpool_param);
  }
  void add_relu_param(flatbuffers::Offset<Relu> relu_param) {
    fbb_.AddOffset(Layer::VT_RELU_PARAM, relu_param);
  }
  void add_softmax_param(flatbuffers::Offset<Softmax> softmax_param) {
    fbb_.AddOffset(Layer::VT_SOFTMAX_PARAM, softmax_param);
  }
  void add_fc_param(flatbuffers::Offset<FC> fc_param) {
    fbb_.AddOffset(Layer::VT_FC_PARAM, fc_param);
  }
  void add_add_param(flatbuffers::Offset<Add> add_param) {
    fbb_.AddOffset(Layer::VT_ADD_PARAM, add_param);
  }
  void add_concat_param(flatbuffers::Offset<Concat> concat_param) {
    fbb_.AddOffset(Layer::VT_CONCAT_PARAM, concat_param);
  }
  void add_affine_param(flatbuffers::Offset<Affine> affine_param) {
    fbb_.AddOffset(Layer::VT_AFFINE_PARAM, affine_param);
  }
  void add_binarize_param(flatbuffers::Offset<Binarize> binarize_param) {
    fbb_.AddOffset(Layer::VT_BINARIZE_PARAM, binarize_param);
  }
  void add_split_param(flatbuffers::Offset<Split> split_param) {
    fbb_.AddOffset(Layer::VT_SPLIT_PARAM, split_param);
  }
  void add_shuffle_param(flatbuffers::Offset<Shuffle> shuffle_param) {
    fbb_.AddOffset(Layer::VT_SHUFFLE_PARAM, shuffle_param);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Layer::VT_NAME, name);
  }
  void add_prelu_param(flatbuffers::Offset<PRelu> prelu_param) {
    fbb_.AddOffset(Layer::VT_PRELU_PARAM, prelu_param);
  }
  explicit LayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerBuilder &operator=(const LayerBuilder &);
  flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layer> CreateLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    LayerType type = LayerType::FpConv2D,
    flatbuffers::Offset<FpConv2D> fp_conv2d_param = 0,
    flatbuffers::Offset<BinConv2D> bin_conv2d_param = 0,
    flatbuffers::Offset<AvePool> avepool_param = 0,
    flatbuffers::Offset<MaxPool> maxpool_param = 0,
    flatbuffers::Offset<Relu> relu_param = 0,
    flatbuffers::Offset<Softmax> softmax_param = 0,
    flatbuffers::Offset<FC> fc_param = 0,
    flatbuffers::Offset<Add> add_param = 0,
    flatbuffers::Offset<Concat> concat_param = 0,
    flatbuffers::Offset<Affine> affine_param = 0,
    flatbuffers::Offset<Binarize> binarize_param = 0,
    flatbuffers::Offset<Split> split_param = 0,
    flatbuffers::Offset<Shuffle> shuffle_param = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<PRelu> prelu_param = 0) {
  LayerBuilder builder_(_fbb);
  builder_.add_prelu_param(prelu_param);
  builder_.add_name(name);
  builder_.add_shuffle_param(shuffle_param);
  builder_.add_split_param(split_param);
  builder_.add_binarize_param(binarize_param);
  builder_.add_affine_param(affine_param);
  builder_.add_concat_param(concat_param);
  builder_.add_add_param(add_param);
  builder_.add_fc_param(fc_param);
  builder_.add_softmax_param(softmax_param);
  builder_.add_relu_param(relu_param);
  builder_.add_maxpool_param(maxpool_param);
  builder_.add_avepool_param(avepool_param);
  builder_.add_bin_conv2d_param(bin_conv2d_param);
  builder_.add_fp_conv2d_param(fp_conv2d_param);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Layer> CreateLayerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    LayerType type = LayerType::FpConv2D,
    flatbuffers::Offset<FpConv2D> fp_conv2d_param = 0,
    flatbuffers::Offset<BinConv2D> bin_conv2d_param = 0,
    flatbuffers::Offset<AvePool> avepool_param = 0,
    flatbuffers::Offset<MaxPool> maxpool_param = 0,
    flatbuffers::Offset<Relu> relu_param = 0,
    flatbuffers::Offset<Softmax> softmax_param = 0,
    flatbuffers::Offset<FC> fc_param = 0,
    flatbuffers::Offset<Add> add_param = 0,
    flatbuffers::Offset<Concat> concat_param = 0,
    flatbuffers::Offset<Affine> affine_param = 0,
    flatbuffers::Offset<Binarize> binarize_param = 0,
    flatbuffers::Offset<Split> split_param = 0,
    flatbuffers::Offset<Shuffle> shuffle_param = 0,
    const char *name = nullptr,
    flatbuffers::Offset<PRelu> prelu_param = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return flatbnn::CreateLayer(
      _fbb,
      type,
      fp_conv2d_param,
      bin_conv2d_param,
      avepool_param,
      maxpool_param,
      relu_param,
      softmax_param,
      fc_param,
      add_param,
      concat_param,
      affine_param,
      binarize_param,
      split_param,
      shuffle_param,
      name__,
      prelu_param);
}

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYERS = 4,
    VT_INITIALIZERS = 6,
    VT_INPUTS = 8,
    VT_VERSION = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<Layer>> *layers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Layer>> *>(VT_LAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *initializers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *>(VT_INITIALIZERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Input>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Input>> *>(VT_INPUTS);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LAYERS) &&
           verifier.VerifyVector(layers()) &&
           verifier.VerifyVectorOfTables(layers()) &&
           VerifyOffset(verifier, VT_INITIALIZERS) &&
           verifier.VerifyVector(initializers()) &&
           verifier.VerifyVectorOfTables(initializers()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_layers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Layer>>> layers) {
    fbb_.AddOffset(Model::VT_LAYERS, layers);
  }
  void add_initializers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> initializers) {
    fbb_.AddOffset(Model::VT_INITIALIZERS, initializers);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Input>>> inputs) {
    fbb_.AddOffset(Model::VT_INPUTS, inputs);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Layer>>> layers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> initializers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Input>>> inputs = 0,
    uint32_t version = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_inputs(inputs);
  builder_.add_initializers(initializers);
  builder_.add_layers(layers);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Layer>> *layers = nullptr,
    const std::vector<flatbuffers::Offset<Tensor>> *initializers = nullptr,
    const std::vector<flatbuffers::Offset<Input>> *inputs = nullptr,
    uint32_t version = 0) {
  auto layers__ = layers ? _fbb.CreateVector<flatbuffers::Offset<Layer>>(*layers) : 0;
  auto initializers__ = initializers ? _fbb.CreateVector<flatbuffers::Offset<Tensor>>(*initializers) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<Input>>(*inputs) : 0;
  return flatbnn::CreateModel(
      _fbb,
      layers__,
      initializers__,
      inputs__,
      version);
}

inline const flatbnn::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<flatbnn::Model>(buf);
}

inline const flatbnn::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<flatbnn::Model>(buf);
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flatbnn::Model>(nullptr);
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<flatbnn::Model>(nullptr);
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flatbnn::Model> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<flatbnn::Model> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbnn

#endif  // FLATBUFFERS_GENERATED_DAB_FLATBNN_H_
